# 贪吃蛇小游戏（无尽模式）
------

基于经典的贪吃蛇小游戏，并没有设置闯关，目的是让同作者同年龄的大姐姐，回味童年。

#### view
* 蛇
* 食物
* 广场
* 墙

#### 实现原理
广场是一个矩形，可以用二维数组实现，每一个数组的项代表广场上的一个小方块
空广场如下：
[
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0]
]
当蛇(1)和食物(2)出现在广场上时：
[
	[**1,1,1**,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,**2**,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0],
	[0,0,0,0,0,0,0,0]
]
根据二维数组的变化，可推算蛇在广场上的位置

#### 开始游戏
* 移动
* 吃食物
* 撞墙
* 自身碰撞

###### 移动
因为是移动端，所以用到的是touch事件改变蛇的移动方向，用setInterval控制蛇的移动速度，在移动过程中需要做两件事：
** 蛇尾的位置设为0 **
```
ground[snakeTAIL[0]][snakeTAIL[1]] = 0;
```
** 蛇头+1的位置设为1 **
```
	for (var i = 1; i < len; i++) {
		ground[arr[i][0]][arr[i][1]] = 1;
	}
```
###### 吃食物
首先判断蛇头与食物的位置是否一样
`snakeHEAD[0] == this.data.food[0] && snakeHEAD[1] == this.data.food[1]`
如果一样：食物所在位置二维数组改为0，蛇的长度加一，重新生成一个食物（位置随机）
###### 撞墙
判断蛇头是否撞墙，这个时候就有问题了，在游戏中并没有设置墙这个概念，怎么进行判断呢？在这里依旧是用到的二维数组，外层数组的就是上下两个方向，内层数组就是左右两个方向。通过蛇所在广场的位置就可以判断是否撞墙了
`snakeHEAD[0] < 0 || snakeHEAD[0] >= this.data.rows || snakeHEAD[1] >= this.data.cols || snakeHEAD[1] < 0`
撞墙只需要清除计时器就OK
###### 自身碰撞
在这里多了一条规定，就是蛇不能撞到自身，这里也需要判断，原理就是蛇头所在的位置是否与蛇身体其他位置是相同的，相同也是清除计时器
`arr[i][0] == snakeHEAD[0] && arr[i][1] == snakeHEAD[1]`
